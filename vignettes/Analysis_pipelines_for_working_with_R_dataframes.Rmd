---
title: "Analysis pipelines - Core functionality and working with R data frames and functions"
author: "Naren Srinivasan, Sanjay"
date: "8/24/2018"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Analysis pipelines for working with R data frames}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- ###TODO: Improve language and description -->

# An overview of the package


# Loading the package

```{r sourcing}
library(analysisPipelines)
```

<br>

# Creating an analysisPipeline object



```{r creating object, warning=F}
obj <- AnalysisPipeline(filePath = system.file("hotel_new.csv", package = "analysisPipelines")) 
obj %>>% setLoggerDetails(target = "file") -> obj
class(obj)
```

The object created is of type <i>"AnalysisPipeline"</i>. The object contains the following attributes:


```{r printing object contents, warning=F}
obj %>>% getInput %>>% str
obj %>>% getRegistry
```

<br>

# Chaining operations


```{r pipe demo 1, warning=F}
# Running univariate categorical distribution plot on the constructed object

obj1 <- obj %>>% univarCatDistPlots(uniCol = "building_type", priColor = "blue", optionalPlots = 0, storeOutput = T)
obj1 %>>% getPipeline
```

```{r pipe demo 2, warning=F}
# Running univariate categorical distribution plot and then 
# outlier detection on the constructed object

obj %>>% univarCatDistPlots(uniCol = "location_type", priColor = "xy", optionalPlots = 0) %>>% 
         outlierPlot(method = "iqr", columnName = "Occupancy", 
              cutoffValue = 0.01, priColor = "blue", optionalPlots = 0, storeOutput = T) -> obj2
obj2 %>>% getPipeline
```

<br>

# Lazy evaluation


```{r lazy eval 1}
length(obj1@output)
```

However, a specific function call can generate the output of the pipeline stored in the object. Which is then stored in the <i>output</i> attribute of the object.

```{r lazy eval 2, warning=F}
obj1Output <- obj1 %>>% generateOutput
length(obj1Output@output)
```

Observe that the length of the output list of the first object (the chunk above) remains 0 since the generated output was assigned to a new object.

```{r lazy eval 2.5, warning=F}
length(obj1@output)
```

A specific output can be viewed by providing the position of the function generating the output in the sequence of operations in the pipeline. This can be obtained from the "order" column in the "pipeline" table corresponding to the function whose output is desired

```{r lazy eval 3, warning=F}
# The index can range from 1 to length(obj@output)
obj1Output %>>% getOutputById("1")
```

<br>

# User-defined functions

## Registering your own function

On invoking the constructor, i.e., creating an object of type AnalysisPipeline, the functions defined in the list are <i>registered</i> for the said object. The list of registered functions can be viewed as <i>obj@registry</i>. The package has the option to add any user-defined function to this list of functions,  <br>
The only <b>constraint</b> for registering an user-defined function is that the first parameter in the argument list must be a data frame.
<br>
Let us demonstrate this with an example.

```{r current register, warning=FALSE}
# Currently registered functions
obj2 %>>% getRegistry()
```

Currently, the package does not have a function to plot bivariate distributions. Let us define a function which can do it for us.

```{r bivariate definition}
bivariatePlots <- function(object, select_var_name_1, select_var_name_2, 
                       priColor = "blue", secColor='black') {
  x=object[, select_var_name_1]
  y=object[, select_var_name_2]
  bivarPlot <- ggplot2::ggplot(object, ggplot2::aes(x,y)) +
    ggplot2::geom_point(color=priColor,alpha=0.7) +
    ggplot2::geom_smooth(method = lm,color=secColor) +
    ggplot2::xlab(select_var_name_1) +
    ggplot2::ylab(select_var_name_2) + 
    ggplot2::theme_bw() +
    ggplot2::ggtitle(paste('Bivariate plot for', select_var_name_1, 
                           'and', select_var_name_2, sep=' ')) +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 10), 
                   axis.text = ggplot2::element_text(size=10),
                   axis.title=ggplot2::element_text(size=10))
  return(bivarPlot)
}
```

This user-defined function can now be registered as part of the AnalysisPipeline object created. Following which, the updated registry will show that the object has at its disposal an additional function which was not defined in the utility.

```{r register function, warning=F}
# The first parameter provides the function name
# The second parameter allows for a header that will feature in the report
# The exceptionFunction parameter allows the user to define a custom exception function in case there is an error during execution
bivarException <- function(error){
  stop("There was an error while plotting bivariate plots due to the provided parameters")
}
obj2 <- obj2 %>>% registerFunction('bivariatePlots', "Bivariate Plots", exceptionFunction = "bivarException")

# Printing the updated registry
obj2 %>>% getRegistry
```

## Using the newly registered function with lazy eval of pipeline

Now that a new user-defined function is also available along with the existing functions, all the features can be leveraged in unison.

```{r register function 2, warning=F}
# Chaining the user-defined function to the object's pipeline where it was registered
obj2 <- obj2 %>>% 
  bivariatePlots(select_var_name_1 = 'Occupancy', select_var_name_2 = 'max_rooms_capacity', 
                 priColor = "blue", secColor = "black")

# Printing the updated pipeline
obj2 %>>% getPipeline
```

The newly added function will also lazy evaluate depending on the trigger.

```{r register function 3, warning=F}
obj2Output <- obj2 %>>% generateOutput()
obj2Output %>>% getOutputById("1") -> a
a
obj2Output@pipeline
```

<br>

# Complex pipelines

## Using the outputs of previous functions in the pipeline, as inputs to arbitrary parameters of subsequent functions
```{r}
getColor <- function(data, color){
  return(color)
}

getColumnName <-function(data, columnName){
  return(columnName)
}


obj %>>% registerFunction("getColor") -> obj

obj %>>% registerFunction("getColumnName") -> obj

obj %>>% getRegistry

obj %>>% getColor(color = "blue") %>>% getColumnName(columnName = "Occupancy", storeOutput = T) %>>%
      univarCatDistPlots(uniCol = "building_type", priColor = ~f1, optionalPlots = 0, storeOutput = T) %>>%
      outlierPlot(method = "iqr", columnName = ~f2, cutoffValue = 0.01, priColor = ~f1 , optionalPlots = 0) -> complexPipeline

complexPipeline %>>% getPipeline
complexPipeline %>>% visualizePipeline
complexPipeline %>>% generateOutput -> op

op %>>% getOutputById("4")
```


# Generating reports

Object and lists stored in the memory are not consumable. Hence, the package allows for the option to knit a pipeline's outputs into a neat HTML file, which can serve as a report of the analysis performed.

```{r generate report and tabs, warning=F,  eval=F}
# generateReport() needs a destination path as an argument
# The function writes a HTML file

obj2Output %>>% generateReport('~/Desktop')
```

In the above case, since the object had the output evaluated and stored in the <i>output</i> attribute, the function call only knits the output into an HTML file. <br>
In the example below, the object has an empty output attribute. The function call, in this case, evaluates the outputs and then knits them into an HTML file.

```{r generate report and tabs 2, message=FALSE, warning=FALSE, eval=FALSE}
objRep <- obj %>>% bivariatePlots('Occupancy', 'PercentTransientNights', 
                           priColor = "blue", secColor = "black")

objRep %>>% generateReport('~/Desktop')
```

<b>NOTE</b>: A sample of the above report can be found in the <i>support/</i> folder of the utility.

<br>

# Saving and loading pipelines

The pipelines stored as an attribute in the object are effectively meta pipelines which document the steps in an EDA pipeline. These can be exported and re-read by certain functions available in this EDA utility. The pipelines are generic enough to work with the schema of the data that was used to invoke the constructor. Therefore, this pipeline can be used on any data of the same schema.

```{r save pipelines, message=FALSE, warning=FALSE, eval=TRUE}
# Saves the pipeline and registry of the EDA object
savePipeline(obj2, 'pipeline.RDS')
```

This pipeline can be loaded and re-used with any other data set.

```{r load pipelines, message=FALSE, warning=FALSE, eval=T}
obj2 <- loadPipeline('pipeline.RDS',filePath = system.file("hotel_new.csv", package = "analysisPipelines")) 

obj2 %>% getRegistry
obj2 %>% getPipeline
```

# Logging & Execution times

# Parallel execution of all-R pipelines



