---
title: "Analysis journey - Approach 1.1 - S4 Class + Pipeline operator + Lazy evaluation + Registry - Prototype/ Example"
author: "Naren Srinivasan"
date: "6/18/2018"
output: html_document
---

```{r setup, include=FALSE}
source("./approach1.1_S4_Pipeline_LazyEval_Registry.R")
```

# Objective

* To prototype an approach using S4 classes,  the pipeline operator to document an journey of analysis into a report
* Enabling lazy evaluation and creation of recipes which can be reused 

# Description of the approach



# Example

## Iniializaing the object

* Data is to be loaded to the R session, and initialized into an object of class "AnalysisReport"

```{r}
data(iris)
analysisRecipeObject <- .AnalysisRecipe(dataset = iris)
str(analysisRecipeObject)
```

## Registering functions

* **Any user defined function** which accepts the dataset as the first argument can be **registered** with the Recipe object
* Below a simple function which calculates the mean of a specified column is defined
* This function is then registered with the recipe object
* The registry shows all possible functions that can be applied on the recipe object using the pipeline operator
* When a function is registered, a *method* [with the name <prefix>+<functionName>] is automatically defined to operate on the analysis recipe object
* This *method* accepts the analysis recipe object as input, and the additional parameters as a named list

```{r}
getSummary <- function(dataset){
  sum <- summary(dataset)
  return(sum)
}

showMethods("ar_getSummary")

analysisRecipeObject %>% registerAnalysisOperation(., "1", "getSummary") -> analysisRecipeObject
analysisRecipeObject@registry

showMethods("ar_getSummary")

```

* We now define another function, which plots 2 variables

```{r}
plotBivariate <- function(dataset, x, y){
  p <- ggplot(data = dataset, aes_string(x = x, y = y, group = 1)) +
    geom_line()
  return(p)
}

showMethods("ar_plotBivariate")

analysisRecipeObject %>% registerAnalysisOperation(., "2", "plotBivariate", list("x", "y")) -> analysisRecipeObject
analysisRecipeObject@registry

showMethods("ar_getSummary")
```


## Pipelining operations and creating recipes

* Different seqeunces of analyses [with varying parameters] can be created as *recipes*
* This is done by calling the auto-generated methods which are created on registration

```{r}
analysisRecipeObject %>% ar_getSummary(.) -> recipe1
str(recipe1)
recipe1@recipe$paramValues

analysisRecipeObject %>% ar_plotBivariate(., list(x = "Sepal.Length", y = "Sepal.Width")) -> recipe2
str(recipe2)
recipe2@recipe$paramValues

analysisRecipeObject %>% ar_getSummary(.) %>%
              ar_plotBivariate(., list(x = "Sepal.Length", y = "Sepal.Width")) -> recipe3
str(recipe3)
recipe3@recipe$paramValues
```

## Viewing results

```{r}
recipe1 %>% collectOutput(.) -> op1
op1@recipe$output

recipe2 %>% collectOutput(.) -> op2
op2@recipe$output

recipe3 %>% collectOutput(.) -> op3
op3@recipe$output
```

# An illustration of lazy load - Changing the dataset

* In this approach, on existing recipes, the dataset can be changed, with the limitation that the same parameters specified in the receipe should be applicable
* Typically, this is the use case of the schema remaning same but new data being data
* The recipe can be used to periodically run the report

```{r}

oldIrisRecipe <- recipe3
oldIrisReport <- op3

oldIrisReport@recipe$output

iris %>% mutate(., Sepal.Length = Sepal.Width^5) -> newIris
newIris <- rbind(newIris, newIris, newIris, newIris, newIris)

recipe3@input$dataset <- newIris
str(recipe3)

recipe3 %>% collectOutput(.) -> newIrisReport

newIrisReport@recipe$output



```




```{r}
obj <- read_input(filePath = 'hotel_new.csv')  %>>% registerFunction('bivarPlots',"Bivariate Plots")

obj <- obj %>>% eda_outlierPlot(method = "iqr",columnName = "Occupancy",cutoffValue = 0.01,priColor = "blue",optionalPlots = 1) %>>% eda_univarCatDistPlots(uniCol = "building_type",priColor = "blue",optionalPlots = 1) %>>% udf_bivarPlots('Occupancy','max_rooms_capacity',priColor = "blue","black") %>>% udf_bivarPlots('Occupancy','max_rooms_capacity',priColor = "blue","black") 

obj1 <- obj %>>% generateOutput()

system.time(obj %>>% generateReport())

system.time(obj1 %>>% generateReport())



```



```{r}
saveRecipe(obj,'obj.RDS')


obj3 <- loadRecipie('obj.RDS',filePath = 'hotel_edited.csv')

obj3 %>>% generateReport()

```

# Conclusion

* This approach provides a consistent way to sequence analysis operations and create recipes
* Recipes can be applied on similar data structures and evaluated to create a report